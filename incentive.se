# Incentive for block header relayers is they can set a fee for use of
# the header they store: they are the initial feeRecipient.
# By paying a changeRecipientFee to feeRecipient, anyone can lower the fee and
# become the feeRecipient: this is a mechanism to prevent excessive fees.

# first 16 bytes are the last gas price; last 16 bytes is the changeRecipientFee
data gasPriceAndChangeRecipientFee


def storeBlockWithFee(blockHeaderBytes:str, feeWei):
    beginGas = msg.gas
    res = self.storeBlockHeader(blockHeaderBytes)
    if res:
        blockHash = m_hashBlockHeader(blockHeaderBytes)
        m_setFeeInfo(blockHash, feeWei, tx.origin)  # note: tx.origin
        remainingGas = msg.gas


        gLastGasPrice = m_getLastGasPrice()

        # TODO can avoid the "else"
        if tx.gasprice < (1023*gLastGasPrice/1024) || tx.gasprice > (1025*gLastGasPrice/1024):
            currGP = gLastGasPrice
        else:
            currGP = tx.gasprice
        gChangeRecipientFee = 2 * currGP * (beginGas - remainingGas)
        gLastGasPrice = currGP

        m_setGasPriceAndChangeRecipientFee(gLastGasPrice, gChangeRecipientFee)

        return(res)


def getFeeRecipient(blockHash):
    return(div(m_getFeeInfo(blockHash), 2**(12*8)))


# TODO callers must send EXACTLY the block's current fee
# There are 2 types of amountWei: the "verifyTxFee" and "changeRecipientFee"
# This does NOT return any funds to incorrect callers
def feePaid(txBlockHash, amountWei):
    feeInfo = m_getFeeInfo(txBlockHash)
    feeRecipient = div(feeInfo, 2**(12*8))
    # TODO allow overpayment?
    if msg.value == amountWei:  # must not allow overpayment, otherwise fees could be increased via changeFeeRecipient()
        send(feeRecipient, msg.value)
        log(type=EthPayment)
        return(1)
    return(0)


# callers must send EXACTLY the block's current fee, AND feeWei must be LESS
# than the block's current fee
# This does NOT return any funds to incorrect callers
def changeFeeRecipient(blockHash, feeWei, feeRecipient):
    if !self.feePaid(blockHash, m_getChangeRecipientFee(), value=msg.value):
        return(0)

    # feeWei is only allowed to decrease
    if feeWei < m_getFeeAmount(blockHash):
        m_setFeeInfo(blockHash, feeWei, feeRecipient)
        return(1)

    return(0)


macro m_getFeeInfo($blockHash):
    self.block[$blockHash]._feeInfo

macro m_setFeeInfo($blockHash, $feeWei, $feeRecipient):
    $word = m_shiftLeft($feeRecipient, 12*8) | $feeWei
    self.block[$blockHash]._feeInfo = $word

macro m_getFeeAmount($blockHash):
    0x0000000000000000000000000000000000000000ffffffffffffffffffffffff & m_getFeeInfo($blockHash)

macro m_getLastGasPrice():
    div(self.gasPriceAndChangeRecipientFee, BYTES_16)

macro m_getChangeRecipientFee():
    (0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff & self.gasPriceAndChangeRecipientFee)

macro m_setGasPriceAndChangeRecipientFee($gasPrice, $changeRecipientFee):
    self.gasPriceAndChangeRecipientFee = ($gasPrice * BYTES_16) | $changeRecipientFee
