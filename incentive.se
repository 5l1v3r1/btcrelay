# 16 bytes last gas price and 16 bytes of change recipient fee
data gasPriceAndChangeRecipientFee

macro m_getLastGasPrice():
    div(self.gasPriceAndChangeRecipientFee, BYTES_16)

macro m_getChangeRecipientFee():
    (0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff & self.gasPriceAndChangeRecipientFee)

macro m_setGasPriceAndChangeRecipientFee($gasPrice, $changeRecipientFee):
    self.gasPriceAndChangeRecipientFee = ($gasPrice * BYTES_16) | $changeRecipientFee

def storeBlockWithFee(blockHeaderBytes:str, feeWei):
    beginGas = msg.gas
    res = self.storeBlockHeader(blockHeaderBytes)
    if res:
        blockHash = m_hashBlockHeader(blockHeaderBytes)
        m_setFeeInfo(blockHash, feeWei, tx.origin)  # note: tx.origin
        remainingGas = msg.gas


        gLastGasPrice = m_getLastGasPrice()

        # TODO can avoid the "else"
        if tx.gasprice < (1023*gLastGasPrice/1024) || tx.gasprice > (1025*gLastGasPrice/1024):
            currGP = gLastGasPrice
        else:
            currGP = tx.gasprice
        gChangeRecipientFee = 2 * currGP * (beginGas - remainingGas)
        gLastGasPrice = currGP

        m_setGasPriceAndChangeRecipientFee(gLastGasPrice, gChangeRecipientFee)

        return(res)


macro m_setFeeInfo($blockHash, $feeWei, $feeRecipient):
    $word = m_shiftLeft($feeRecipient, 12*8) | $feeWei
    self.block[$blockHash]._feeInfo = $word


macro m_getFeeInfo($blockHash):
    self.block[$blockHash]._feeInfo

def getFee(blockHash):
    # TODO macro
    return(0x0000000000000000000000000000000000000000ffffffffffffffffffffffff & m_getFeeInfo(blockHash))

def getFeeRecipient(blockHash):
    return(div(m_getFeeInfo(blockHash), 2**(12*8)))

# TODO callers must send EXACTLY the block's current fee
# There are 2 types of amountWei: the "verifyTxFee" and "changeRecipientFee"
# This does NOT return any funds to incorrect callers
def feePaid(txBlockHash, amountWei):
    feeInfo = m_getFeeInfo(txBlockHash)
    feeRecipient = div(feeInfo, 2**(12*8))
    # TODO allow overpayment?
    if msg.value == amountWei:  # must not allow overpayment, otherwise fees could be increased via changeFeeRecipient()
        send(feeRecipient, msg.value)
        log(type=EthPayment)
        return(1)
    return(0)


# callers must send EXACTLY the block's current fee, AND feeWei must be LESS
# than the block's current fee
# This does NOT return any funds to incorrect callers
def changeFeeRecipient(blockHash, feeWei, feeRecipient):
    if !self.feePaid(blockHash, m_getChangeRecipientFee(), value=msg.value):
        return(0)

    # feeWei is only allowed to decrease
    if feeWei < self.getFee(blockHash):  # TODO macro
        m_setFeeInfo(blockHash, feeWei, feeRecipient)
        return(1)

    return(0)
