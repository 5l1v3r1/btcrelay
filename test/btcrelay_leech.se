
extern realBTCRelay: [within6Confirms:[int256]:int256,inMainChain:[int256]:int256,computeMerkle:[int256,int256,int256[]]:uint256]

def freeVerifyTx(btcrelay, txBytes:str, txIndex, sibling:arr, blockHeaderBytes:str):
    txBlockHash = m_dblShaFlip(blockHeaderBytes)
    txHash = m_dblShaFlip(txBytes)

    if btcrelay.within6Confirms(txBlockHash):
        return(99:uint256)

    if !btcrelay.inMainChain(txBlockHash):
        return(88:uint256)

    # return(btcrelay.computeMerkle(txHash, txIndex, sibling):uint256)
    return(m_getMerkleRoot(blockHeaderBytes):uint256)

    if btcrelay.computeMerkle(txHash, txIndex, sibling) == m_getMerkleRoot(blockHeaderBytes):
        return(txHash:uint256)
    return(0:uint256)


macro m_getMerkleRoot($blockHeaderBytes):
    flip32Bytes(slice($blockHeaderBytes, chars=36, chars=68))

    # slice($blockHeaderBytes, chars=36, chars=68)

    # load($blockHeaderBytes, chars=1)

    # with $addr = ref($blockHeaderBytes):
        # sload($addr)
        # $addr
        #load($blockHeaderBytes, chars=80)
        # load($addr, items=80)
        # sload($addr+1)
    # with $addr = ref($blockHeaderBytes[0]):
    # with $addr = $blockHeaderBytes:
    #     flip32Bytes(sload($addr+1) * BYTES_4 + div(sload($addr+2), BYTES_28))  # must use div()


macro BYTES_4: 2**32
macro BYTES_28: 2**224


# reverse 32 bytes given by '$b32'
macro flip32Bytes($b32):
    with $a = $b32:  # important to force $a to only be examined once below
        with $i = 0:
            # unrolling this would decrease gas usage, but would increase
            # the gas cost for code size by over 700K and exceed the PI million block gas limit
            while $i < 32:
                mstore8(ref($o) + $i, byte(31 - $i, $a))
                $i += 1
    $o

# Bitcoin-way of hashing
macro m_dblShaFlip($dataBytes):
    flip32Bytes(sha256(sha256($dataBytes:str)))
